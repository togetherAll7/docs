---
title: Scaling performance
description: This is a short primer on how to scale performance.
nav: 11
---

Running WebGL can be expensive and taxing depending on the capacity of the device. In order to mitigate this you should look into performance optimizations.

This article teaches you how to employ these strategies.

## On-demand rendering

By default Three-fiber runs in a game-loop, that means it executes 60 times per second. This is the fastest, but also the most demanding and wasteful, it also affects the battery the most. You can opt into on-demand rendering instead, which will only render when props anywhere in the tree change.

If you open devtools in the sandbox below you will see that it is completely idle when nothing is moving.

<Codesandbox id="wvgxp" />

This is how you activate it.

```jsx
<Canvas frameloop="demand">
```

Use the `invalidate` function to trigger frames manually. This is useful when something is temporarily moving, for instance an animation. If you had controls for instance, it would be a good idea to stick it into the `change` event. Drei's controls [do this automatically](https://github.com/pmndrs/drei/blob/master/src/core/OrbitControls.tsx#L40) for you. If you use react-spring to animate your scene, then it will also call `invalidate()` for you.

```jsx
import { invalidate } from '@react-three/fiber'

// Anywhere you need it
invalidate()
```

<Hint>
  Calling invalidate() will not cause it to render immediately, it merely requests a new frame.
</Hint>

## Re-using objects and materials

Each geometry is a draw call and each material is a program. You should try your very best to re-use them.

<Codesandbox id="dix1y" />

You could do this globally:

```jsx
const material = new THREE.MeshLambertMaterial({ color: "red" })
const geometry = new THREE.SphereGeometry(1, 28, 28)

function Scene() {
  return (
    <>
      <mesh geometry={sphere} material={red} />
      <mesh position={[1, 2, 3]} geometry={sphere} material={red} />
```

And if you use GLTF in combination with [gltfjsx](https://github.com/pmndrs/gltfjsx) that is done for you because all `useLoader` assets are cached.

```jsx
function Model(props) {
  const { nodes, materials } = useGLTF("/model.glb")
  return <mesh geometry={nodes.robot.geometry} material={materials.metal} {...props} />
}

<Model position={[1, 2, 3]} />
<Model position={[4, 5, 6]} />
```

## Instancing

You should be mindful of how many draw calls you employ. You should have no more than 1000 as the very maximum, and optimally a few hundred or less. You can win performance back by reducing draw calls by instancing repeating objects. This way you can have hundreds of thousands of objects in a single draw call.

<Codesandbox id="8fo01" />

Setting up instancing is not so hard, consult [the Threejs docs](https://threejs.org/docs/index.html?q=instance#api/en/objects/InstancedMesh) if you need help.

```jsx
const obj = new THREE.Object3D()
function Instances({ count = 1000000 }) {
  const ref = useRef()
  useEffect(() => {
    for (let i = 0; i < count; i++) {
      obj.position.set(Math.random(), Math.random(), Math.random())
      obj.updateMatrix()
      ref.current.setMatrixAt(id, obj.matrix)
    }
    ref.current.instanceMatrix.needsUpdate = true
  }, [])
  return (
    <instancedMesh ref={ref} args={[null, null, count]}>
      <boxGeometry />
      <meshPhongMaterial />
    </instancedMesh>
  )
}
````

## Level of detail

You use LODs to reduce quality the further an object is away. That can be a good strategy to reduce the vertex-count.

Scroll in and out to see the effect:

<Codesandbox id="12nmp" />

There is a small component in drei called `<Detailed />` which sets up LOD without boilerplate. You load or prepare a couple of stages, as many as you like, and then give them the same amount of distances from the camera, starting from highest quality to lowest.

```jsx
import { Detailed, useGLTF } from '@react-three/drei'

function Scene() {
  const [low, mid, high] = useGLTF(["/low.glb", "/mid.glb", "/high.glb"])
  return (
    <Detailed distances={[0, 10, 20]}>
      <mesh geometry={high} />
      <mesh geometry={mid} />
      <mesh geometry={low} />
    <Detailed/>
  )
}
```

## Nested loading

Nested loading means that lesser textures and models are loaded first, higher-resolution later.

The following sandbox goes through three loading stages:

- A loading indicator
- Low quality
- High quality

<Codesandbox id="7duy8" />

And this is how easy it is to achieve it, you can nest suspense and even use it as a fallback:

```jsx
function App() {
  return (
    <Suspense fallback={<span>loading...</span>}>
      <Canvas>
        <Suspense fallback={<Model url="/low-quality.glb" />}>
          <Model url="/high-quality.glb" />
        </Suspense>
      </Canvas>
    </Suspense>
  )
}

function Model({ url }) {
  const { scene } = useGLTF(url)
  return <primitive object={scene} />
}
```

## Movement regression

Websites like Sketchfab make sure the scene is always fluid, running at 60 fps, and responsive, no matter which device is being used or how expensive a loaded model is. They do this by regressing movement, where effects, textures, shadows will slightly reduce quality until still-stand

The following sandbox uses expensive lights and post-processing. In order for it to run relatively smooth it will scale the pixel ratio on movement and also skip heavy post-processing effects like ambient occlusion.

<Codesandbox id="pz0q6" />

When you inspect the state model you will notice an object called `performance`.

```jsx
performance: {
  current: 1,
  min: 0.1,
  max: 1,
  debounce: 200,
  regress: () => void,
},
```

- current: Performance factor alternates between min and max
- min: Performance lower bound (should be less than 1)
- max: Performance upper bound (no higher than 1)
- debounce: Debounce timeout until it goes to upper bound (1) again
- regress(): Function that temporarily regresses performance

You can define defaults like so:

```jsx
<Canvas performance={{ min: 0.5 }}>...</Canvas>
```

### This is how you can put the system into regression

The only thing you have to do is call `regress()`. When exactly you do that, that is up to you, but it could be when when the mouse moves, or the scene is moving, for instance when controls fire their change-event.

Say you are using controls, then the following code puts the system in regress when they are active:

```jsx
const regress = useThree((state) => state.performance.regress)
useEffect(() => {
  controls.current?.addEventListener('change', regress)
```

### This is how you can respond to it

<Hint>Mere calls to regress() will not change or affect anything!</Hint>

Your app has to opt into performance scaling by listening to the performance `current`! The number itself will tell you what to do. 1 (max) means everything is ok, the default. Less than 1 (min) means a regression is requested and the number itself tells you how far you should go when scaling down.

For instance, you could simply multiply `current` with the pixelratio to cut down on resolution. If you have defined `min: 0.5` that would mean it will half the resolution for at least 200ms (delay) when regress is called. It can be used for anything else, too: switching off lights when `current < 1`, using lower-res textures, skip post-processing effects, etc. You could of course also animate/lerp these changes.

Here is a small prototype component that scales the pixel ratio:

```jsx
function AdaptivePixelRatio() {
  const current = useThree((state) => state.performance.current)
  const setPixelRatio = useThree((state) => state.setPixelRatio)
  useEffect(() => {
    setPixelRatio(window.devicePixelRatio * current)
  }, [current])
  return null
}
```

Drop this component into the scene, combine it with the code above that calls `regress()`, and you have adaptive resolution:

```jsx
<AdaptivePixelRatio />
```

There are pre-made components for this already in the [drei library](https://github.com/pmndrs/drei/#performance).
