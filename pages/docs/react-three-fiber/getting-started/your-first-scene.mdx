import Callout from 'nextra-theme-docs/callout'
import Bleed from 'nextra-theme-docs/bleed'

# Your First Scene

This guide will help you setup your first React Three Fiber scene and introduce you to its core concepts. 

## The Canvas

Every scene starts with  the `<Canvas />` component, which we can import from `react-three-fiber`:

<Bleed>
  <iframe 
    src="https://codesandbox.io/embed/12q81?codemirror=1&fontsize=14&hidenavigation=1&theme=dark&highlights=2,8,13&hidedevtools=1"
    style={{
      width: "100%",
      height: 600,
      overflow: "hidden",
      borderRadius: 4,
      border: "0px",
      marginTop: 16
    }}
    title="getting-started-01"
    allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
    sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"
  ></iframe>
</Bleed>

In the example above, we can start getting familiar with some of the **basic concepts** of React Three Fiber:
1. We set a **camera** prop for the `<Canvas />` component. This is the initial position of Fiber's default **PerspectiveCamera** - which would otherwise be at `[0, 0, 5]`

2. We added a `<color />` component with `args` and `attach` props. This means that a new `THREE.Color` object will be created and set as the `background` property of the main `scene`.

<Bleed>
  ```js
  const color = new THREE.Color('black') // args is the arguments array, passed to the constructor
  scene.background = color // set the property on a three.js object parent[attach] = object
  ```
</Bleed>

3. We added a `<mesh />` component with a `<boxBufferGeometry />` child. Any component with `geometry` or `material` in its name, will automatically attach to the corresponding property of its parent:
  ```js
  const myMesh = new THREE.Mesh() // <mesh />
  const myGeometry = new THREE.BoxBufferGeometry() // <boxBufferGeometry />

  myMesh.geometry = myGeometry // set the `geometry` property on our mesh
  ```

<Callout>
  The `<Canvas />` will fill its parent element (try changing the width and height of `.App` in `src/styles.css`)
</Callout>

**React Three Fiber can render any object from three.js**, using these simple rules:

- components will be camel-case, so `THREE.Mesh` will be `<mesh />` and `THREE.BoxBufferGeometry` will be `<boxBufferGeometry />`
  
- constructor arguments will be passed via the `args` prop, so `new THREE.Color("red")` will become `<color args={["red"]} />`

This gives you an initial idea of how React Three Fiber will work, but let's dive deeper!

## Meshes, Geometries and Materials

In the previous example, we created a `<mesh />` component with a `<boxBufferGeometry />` child.

This is equivalent to creating those objects in three.js, putting them together and adding them to the scene:

```js
const mesh = new THREE.Mesh()
const geometry = new THREE.BoxBufferGeometry()

mesh.geometry = geometry
scene.add(mesh)
```

We can add materials in the same way, let's say we want to use [`THREE.MeshNormalMaterial`](), we will have to use a camel-case version of the name, in this case `<meshPhysicalMaterial />`:

<Bleed>
<iframe 
  src="https://codesandbox.io/embed/cvxpd?codemirror=1&fontsize=14&hidenavigation=1&theme=dark&highlights=9&hidedevtools=1"
  style={{
    width: "100%",
    height: 600,
    overflow: "hidden",
    borderRadius: 4,
    border: "0px",
    marginTop: 16
  }}
  title="getting-started-01"
  allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
  sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"
></iframe>
</Bleed>

**Exercise:**
- try different materials, like [`<meshPhongMaterial />`](https://threejs.org/docs/#api/en/materials/MeshPhongMaterial) or [`<meshBasicMaterial />`](https://threejs.org/docs/#api/en/materials/MeshBasicMaterial)
- try different geometries, like [`<sphereBufferGeometry />`](https://threejs.org/docs/#api/en/geometries/SphereBufferGeometry) or [`<octahedronBufferGeometry />`](https://threejs.org/docs/#api/en/geometries/OctahedronBufferGeometry)

## Loading Textures

We will now add a simple [`texture`](https://threejs.org/docs/index.html#api/en/textures/Texture) to our box, to make it look less boring!

This example will introduce you to the concept of three's **Loaders**, Fiber's [**useLoader**](/api/useloader) hook and a sprinkle of React's **Suspense**.

<Bleed>
<iframe 
  src="https://codesandbox.io/embed/xxrlt?codemirror=1&fontsize=14&hidenavigation=1&theme=dark&highlights=6,7,8,9,22,24&hidedevtools=1"
  style={{
    width: "100%",
    height: 600,
    overflow: "hidden",
    borderRadius: 4,
    border: "0px",
    marginTop: 16
  }}
  title="getting-started-01"
  allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
  sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"
></iframe>
</Bleed>

Let's take a closer look:

- we moved our box *mesh* to its own component, since **React Three Fiber Hooks** can only be used inside `<Canvas />` children.
- we imported the `useLoader` hook from Fiber.
  *useLoader* expects at least two arguments, the first being a three.js `Loader` constructor, and the second being the url of the resource you want to load
  ```jsx
  useLoader(THREE.TextureLoader, url)
  ```
- we wrapped our `<MyBox />` component with a React Suspense block.
  ```jsx
    <React.Suspense fallback={null}>
      <MyBox />
    </React.Suspense>
  ```
  By doing this, we tell React that our component should not be rendered until our texture is finished loading, and that instead we want to render whatever element is passed to `fallback`. 
  We will be just using `null` for now, but we will build something nicer later!
  <Callout>
    React Suspense is a big topic, we will get back to it later, but if you want to learn more, you should read this page.
  </Callout>

- Finally, we assign our newly loaded texture to the `map` property of `MeshBasicMaterial`

**Exercise:**
- try scaling the texture and changing its wrapping modes:

```jsx
// texture is scaled down to repeat twice
myTexture.repeat.set(2, 2) 
// texture will now repeat both horizontally and vertically
myTexture.wrapS = myTexture.wrapT = THREE.RepeatWrapping 
```

You can just add these lines right after assigning `myTexture` (line 10).

<Callout>
We can also simplify our texture loading by using drei's [`useTexture`](https://github.com/pmndrs/drei#usetexture)
</Callout>

## Loading 3D Models

Boxes are boring, we all know that. Let's load a `gltf` file, and get introduced to the React Three Fiber ecosystem:

We will add a new dependency to our project, [`@react-three/drei`](https://github.com/pmndrs/drei). 
Drei is a collection of useful helpers and abstractions for Fiber, and we will use a few of its components to improve our example.

<Bleed>
<iframe 
  src="https://codesandbox.io/embed/kmdi5?codemirror=1&fontsize=14&hidenavigation=1&theme=dark&highlights=6,7,8,9,22,24&hidedevtools=1"
  style={{
    width: "100%",
    height: 600,
    overflow: "hidden",
    borderRadius: 4,
    border: "0px",
    marginTop: 16
  }}
  title="getting-started-01"
  allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
  sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"
></iframe>
</Bleed>

- we put our files in `public/model`, so that our resource will be served by the web server
- we load our model with drei's [`useGLTF`](https://github.com/pmndrs/drei#usetexture). Here's what's happening, in detail:
  - Suspense is triggered by `useGLTF`, so our component will not render until it's done loading
  - The `.gltf` file is fetched
  - All the related files (binaries and images) are fetched
  - Suspense is resolved and our component can now finally render
- we destructure nodes (the model's objects) and materials and assign them to a mesh's geometry and material

BONUS: we can add [OrbitControls](https://threejs.org/docs/index.html#examples/en/controls/OrbitControls) by using drei's `<OrbitControls />` component - try dragging and scrolling in the scene

Phew, that's a lot to unpack. We will make this process easier later, when we'll introduce the [**gltfjsx**](https://github.com/pmndrs/gltfjsx) utility.

**Exercise:**
  - try console logging the result of `useGLTF`, to see just what's returned from the hook
  - try to load a `.glb` file - you can find some free-to-use files here https://github.com/KhronosGroup/glTF-Sample-Models/

## Moving to components

We will now refactor our previous example to better use React's strong suite, components!

<Bleed>
<iframe 
  src="https://codesandbox.io/embed/wudry?codemirror=1&fontsize=14&hidenavigation=1&theme=dark&highlights=5,6,7,8,9,10,11,12&hidedevtools=1"
  style={{
    width: "100%",
    height: 600,
    overflow: "hidden",
    borderRadius: 4,
    border: "0px",
    marginTop: 16
  }}
  title="getting-started-01"
  allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
  sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"
></iframe>
</Bleed>

In the example, we created a new `MyBox` component that will render a new `mesh`, and we reuse it twice, with different `position` and `color` props.
